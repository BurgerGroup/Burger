## 协程模块

```
Coroutine::GetCurCo()

Thread -> main_co <-----------> sub_co
            |
            |
          sub_co

main_co 负责切换，回收, 不分配栈空间
```

协程调度模块scheduler

如何让协程在线程间切换

```
    1    --     N      1 -- M
scheduler --> thread --> co

        N  - --------  M 
1. 执行器Processor,每一个IO线程都有一个独一无二的Processor
2. 协程调度器，将协程，指定到相应的线程(Processor)上去执行

```

## FAQ 

* 1. `CoEpoller`的作用？为什么源码里是wait？
    答：协程因为阻塞swapOut之后，需要`CoEpoller`来监听状态；在事件来临时，将对应的协程重新加入就绪队列。
    （简洁地说：没有协程可执行，就epoll监听事件，来临时获取对应协程）
    libgo中，是在processor中swapout，然后在就绪队列中获取下一个协程，没有协程时当然就是wait等待添加协程。

* 2. co从coQue里pop后，swapout时会重新加入队列吗？（不会的话是怎么再次调度到他的）
    答：在swapout时，有两种情况：
        1. 协程执行完毕；2.协程任务阻塞。而在阻塞时，协程会将需要监听的fd上树，等待准备好时再次执行。

* 3. Hook的作用
    答：在内核级线程中，如果线程被io等操作阻塞，内核会自动帮我们切换线程；用户级线程（也即是协程）在被阻塞时，内核没有感知，就需要我们自己来进行切换————通过返回值+错误码即可判断是否是阻塞状态。
    简言之，hook使我们的processor有了看上去类似系统自动调度线程的**自动调度协程的能力**（虽然本质上是协程自己决定换出）
