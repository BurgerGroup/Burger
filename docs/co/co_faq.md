## FAQ 

* 1. `CoEpoller`的作用？为什么源码里是wait？
    答：协程因为阻塞Yield之后，需要`CoEpoller`来监听状态；在事件来临时，将对应的协程重新加入就绪队列。
    （简洁地说：没有协程可执行，就epoll监听事件，来临时获取对应协程）
    libgo中，是在processor中Yield，然后在就绪队列中获取下一个协程，没有协程时当然就是wait等待添加协程。

* 2. co从coQue里pop后，Yield时会重新加入队列吗？（不会的话是怎么再次调度到他的）
    答：在Yield时，有两种情况：
        1. 协程执行完毕；2.协程任务阻塞。而在阻塞时，协程会将需要监听的fd上树，等待准备好时再次执行。

